"""
3D Renderer for Interactive Tank Armor Simulation Visualizations

This module handles the actual rendering of 3D visualizations using matplotlib,
providing interactive controls, animations, and professional presentation.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection
import matplotlib.patches as patches
from matplotlib.widgets import Slider, Button, CheckButtons
import matplotlib.animation as animation
from matplotlib.colors import LinearSegmentedColormap, Normalize
import matplotlib.cm as cm
from typing import List, Dict, Tuple, Optional, Any, Callable
import time

from .interactive_3d import Interactive3DVisualizer, Environmental3DEffects


class Interactive3DRenderer:
    """
    Main 3D rendering class that creates interactive matplotlib visualizations.
    """
    
    def __init__(self, figsize=(16, 12), style='professional'):
        """
        Initialize the 3D renderer.
        
        Args:
            figsize: Figure size tuple
            style: Visualization style ('professional', 'tactical', 'educational')
        """
        self.figsize = figsize
        self.style = style
        self.fig = None
        self.ax_3d = None
        self.ax_controls = None
        
        # Interaction state
        self.current_view_angle = [30, 45]  # elevation, azimuth
        self.zoom_level = 1.0
        self.animation_speed = 1.0
        self.show_environmental_effects = True
        self.show_armor_zones = True
        self.show_trajectory = True
        
        # 3D visualization components
        self.visualizer = Interactive3DVisualizer()
        self.environmental_effects = Environmental3DEffects()
        
        # Cached 3D objects for performance
        self.tank_model_cache = None
        self.trajectory_cache = None
        self.effects_cache = None
        
        # Color schemes
        self.color_schemes = self._setup_color_schemes()
        
        # Interactive widgets
        self.sliders = {}
        self.buttons = {}
        self.checkboxes = {}
        
    def _setup_color_schemes(self) -> Dict[str, Dict]:
        """Set up color schemes for different visualization styles."""
        
        schemes = {
            'professional': {
                'tank_hull': '#2E4057',      # Dark blue-gray
                'tank_turret': '#3C5875',    # Medium blue-gray  
                'tank_gun': '#1A1A1A',      # Dark gray
                'tank_tracks': '#333333',    # Charcoal
                'armor_zones': '#FF6B6B',    # Red for armor
                'trajectory': '#4ECDC4',     # Teal for trajectory
                'impact_point': '#FFE66D',   # Yellow for impact
                'penetration': '#FF4757',    # Red for penetration
                'spall': '#FFA502',          # Orange for spall
                'environment': '#A8E6CF',    # Light green for environment
                'background': '#F8F9FA'      # Light background
            },
            'tactical': {
                'tank_hull': '#2D5016',      # Military green
                'tank_turret': '#3E6B1F',    # Darker green
                'tank_gun': '#1C1C1C',      # Black
                'tank_tracks': '#2C2C2C',    # Dark gray
                'armor_zones': '#C0392B',    # Dark red
                'trajectory': '#F39C12',     # Orange trajectory
                'impact_point': '#E74C3C',   # Red impact
                'penetration': '#8E44AD',    # Purple penetration
                'spall': '#E67E22',          # Dark orange spall
                'environment': '#27AE60',    # Green environment
                'background': '#2C3E50'      # Dark background
            },
            'educational': {
                'tank_hull': '#3498DB',      # Blue hull
                'tank_turret': '#2980B9',    # Darker blue
                'tank_gun': '#34495E',       # Dark blue-gray
                'tank_tracks': '#7F8C8D',    # Gray tracks
                'armor_zones': '#E74C3C',    # Red zones
                'trajectory': '#F1C40F',     # Yellow trajectory
                'impact_point': '#E67E22',   # Orange impact
                'penetration': '#9B59B6',    # Purple penetration
                'spall': '#1ABC9C',          # Turquoise spall
                'environment': '#2ECC71',    # Green environment
                'background': '#ECF0F1'      # Light gray background
            }
        }
        
        return schemes
    
    def create_complete_3d_visualization(self, ammunition, armor, 
                                       target_range: float = 2000.0,
                                       impact_angle: float = 15.0,
                                       launch_angle: float = 2.0,
                                       environmental_conditions: Optional[Dict] = None) -> plt.Figure:
        """
        Create a complete interactive 3D visualization with all features.
        
        Args:
            ammunition: Ammunition object
            armor: Armor object
            target_range: Distance to target in meters
            impact_angle: Impact angle in degrees
            launch_angle: Launch elevation angle in degrees
            environmental_conditions: Environmental parameters
            
        Returns:
            Complete matplotlib figure with interactive 3D visualization
        """
        
        # Set up the figure and 3D axis
        self.fig = plt.figure(figsize=self.figsize)
        
        # Main 3D axis (takes up most of the space)
        self.ax_3d = self.fig.add_subplot(111, projection='3d')
        
        # Set up the 3D environment
        self._setup_3d_environment()
        
        # Create tank model
        tank_model = self.visualizer.create_3d_tank_model('modern_mbt')
        self._render_tank_model(tank_model)
        
        # Create and render trajectory
        if environmental_conditions is None:
            environmental_conditions = {
                'wind_speed': 5.0,
                'wind_direction': 45.0,
                'temperature': 15.0,
                'altitude': 0.0,
                'humidity': 50.0
            }
        
        trajectory_data = self.visualizer.create_3d_trajectory(
            ammunition, target_range, launch_angle, environmental_conditions
        )
        self._render_trajectory(trajectory_data)
        
        # Calculate impact point from trajectory
        if trajectory_data['trajectory_points']:
            impact_point = trajectory_data['trajectory_points'][-1]['position']
        else:
            impact_point = [target_range, 0, 0]  # Fallback
        
        # Create penetration analysis
        penetration_analysis = self.visualizer.create_3d_penetration_analysis(
            ammunition, armor, impact_point, impact_angle
        )
        self._render_penetration_analysis(penetration_analysis)
        
        # Render environmental effects
        if self.show_environmental_effects:
            self._render_environmental_effects(environmental_conditions)
        
        # Set up interactive controls
        self._setup_interactive_controls(ammunition, armor, environmental_conditions)
        
        # Apply styling
        self._apply_visual_styling()
        
        # Set initial view
        self.ax_3d.view_init(elev=self.current_view_angle[0], azim=self.current_view_angle[1])
        
        return self.fig
    
    def _setup_3d_environment(self):\n        \"\"\"Set up the 3D plotting environment and axes.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Set background color\n        self.fig.patch.set_facecolor(colors['background'])\n        self.ax_3d.set_facecolor(colors['background'])\n        \n        # Set axis labels and styling\n        self.ax_3d.set_xlabel('Distance (m)', fontsize=10, fontweight='bold')\n        self.ax_3d.set_ylabel('Lateral Offset (m)', fontsize=10, fontweight='bold')\n        self.ax_3d.set_zlabel('Height (m)', fontsize=10, fontweight='bold')\n        \n        # Set reasonable axis limits for tank scenario\n        self.ax_3d.set_xlim(-5, 25)   # Tank at 0, target at ~20m+\n        self.ax_3d.set_ylim(-8, 8)    # Lateral spread\n        self.ax_3d.set_zlim(-1, 8)    # Ground to reasonable height\n        \n        # Grid and styling\n        self.ax_3d.grid(True, alpha=0.3)\n        \n        # Create ground plane\n        self._create_ground_plane()\n    \n    def _create_ground_plane(self):\n        \"\"\"Create a ground plane for reference.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Ground plane vertices\n        ground_x = [-5, 25, 25, -5]\n        ground_y = [-8, -8, 8, 8]\n        ground_z = [0, 0, 0, 0]\n        \n        # Create ground plane\n        ground_verts = [list(zip(ground_x, ground_y, ground_z))]\n        \n        ground_collection = Poly3DCollection(ground_verts, alpha=0.2, \n                                           facecolors='lightgray', \n                                           edgecolors='gray', linewidths=0.5)\n        \n        self.ax_3d.add_collection3d(ground_collection)\n    \n    def _render_tank_model(self, tank_model: Dict[str, Any]):\n        \"\"\"Render the 3D tank model with all components.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Render hull\n        self._render_tank_component(tank_model['hull'], colors['tank_hull'], 'Hull')\n        \n        # Render turret\n        self._render_tank_component(tank_model['turret'], colors['tank_turret'], 'Turret')\n        \n        # Render gun\n        self._render_tank_component(tank_model['gun'], colors['tank_gun'], 'Gun')\n        \n        # Render tracks\n        self._render_tank_component(tank_model['tracks']['left'], colors['tank_tracks'], 'Track L')\n        self._render_tank_component(tank_model['tracks']['right'], colors['tank_tracks'], 'Track R')\n        \n        # Render armor zones if enabled\n        if self.show_armor_zones:\n            self._render_armor_zones(tank_model['armor_zones'])\n    \n    def _render_tank_component(self, component: Dict[str, np.ndarray], color: str, label: str):\n        \"\"\"Render a single tank component.\"\"\"\n        \n        if 'vertices' not in component or 'faces' not in component:\n            return\n            \n        vertices = component['vertices']\n        faces = component['faces']\n        \n        # Create face collections\n        face_verts = []\n        for face in faces:\n            if len(face) >= 3:  # Ensure valid face\n                face_coords = vertices[face]\n                face_verts.append(face_coords)\n        \n        if face_verts:\n            collection = Poly3DCollection(face_verts, alpha=0.8, \n                                        facecolors=color, \n                                        edgecolors='black', linewidths=0.5)\n            self.ax_3d.add_collection3d(collection)\n    \n    def _render_armor_zones(self, armor_zones: Dict[str, Dict]):\n        \"\"\"Render armor protection zones.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        for zone_name, zone_data in armor_zones.items():\n            if isinstance(zone_data.get('area'), list) and len(zone_data['area']) >= 3:\n                # Create armor zone visualization\n                zone_verts = [zone_data['area']]\n                \n                # Color intensity based on armor thickness\n                thickness = zone_data.get('thickness', 300)\n                alpha = min(0.8, max(0.2, thickness / 1000))  # Scale alpha with thickness\n                \n                armor_collection = Poly3DCollection(zone_verts, alpha=alpha,\n                                                   facecolors=colors['armor_zones'],\n                                                   edgecolors='darkred', linewidths=1.5)\n                \n                self.ax_3d.add_collection3d(armor_collection)\n                \n                # Add thickness label\n                center = np.mean(zone_data['area'], axis=0)\n                self.ax_3d.text(center[0], center[1], center[2] + 0.2, \n                              f\"{thickness}mm\", fontsize=8, \n                              ha='center', va='bottom')\n    \n    def _render_trajectory(self, trajectory_data: Dict[str, Any]):\n        \"\"\"Render the 3D ballistic trajectory.\"\"\"\n        \n        if not self.show_trajectory or not trajectory_data.get('trajectory_points'):\n            return\n        \n        colors = self.color_schemes[self.style]\n        trajectory_points = trajectory_data['trajectory_points']\n        \n        # Extract trajectory coordinates\n        trajectory_x = [point['position'][0] for point in trajectory_points]\n        trajectory_y = [point['position'][1] for point in trajectory_points]\n        trajectory_z = [point['position'][2] for point in trajectory_points]\n        \n        # Plot trajectory line with velocity color mapping\n        speeds = [point['speed'] for point in trajectory_points]\n        \n        # Create colored trajectory segments\n        for i in range(len(trajectory_points) - 1):\n            # Color based on velocity (blue = fast, red = slow)\n            speed_ratio = speeds[i] / max(speeds) if max(speeds) > 0 else 0\n            segment_color = plt.cm.plasma(speed_ratio)\n            \n            self.ax_3d.plot([trajectory_x[i], trajectory_x[i+1]], \n                          [trajectory_y[i], trajectory_y[i+1]], \n                          [trajectory_z[i], trajectory_z[i+1]], \n                          color=segment_color, linewidth=3, alpha=0.8)\n        \n        # Add projectile positions at key intervals\n        interval = max(1, len(trajectory_points) // 10)  # Show ~10 projectiles\n        for i in range(0, len(trajectory_points), interval):\n            pos = trajectory_points[i]['position']\n            \n            # Simple projectile representation\n            self.ax_3d.scatter(pos[0], pos[1], pos[2], \n                             c=colors['trajectory'], s=30, alpha=0.7,\n                             marker='o', edgecolors='black')\n        \n        # Mark launch point\n        self.ax_3d.scatter(trajectory_x[0], trajectory_y[0], trajectory_z[0], \n                         c='green', s=100, marker='^', \n                         edgecolors='black', linewidth=2, \n                         label='Launch Point')\n        \n        # Mark impact point\n        self.ax_3d.scatter(trajectory_x[-1], trajectory_y[-1], trajectory_z[-1], \n                         c=colors['impact_point'], s=150, marker='X', \n                         edgecolors='black', linewidth=2, \n                         label='Impact Point')\n    \n    def _render_penetration_analysis(self, penetration_analysis: Dict[str, Any]):\n        \"\"\"Render 3D penetration analysis visualization.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Render penetration channel\n        if 'cross_section_data' in penetration_analysis:\n            self._render_penetration_channel(penetration_analysis['cross_section_data'])\n        \n        # Render armor response\n        if 'armor_response' in penetration_analysis:\n            self._render_armor_response(penetration_analysis['armor_response'])\n        \n        # Render behind-armor effects\n        if 'behind_armor_effects' in penetration_analysis:\n            self._render_behind_armor_effects(penetration_analysis['behind_armor_effects'])\n        \n        # Mark impact point\n        impact_point = penetration_analysis.get('impact_point', [0, 0, 0])\n        self.ax_3d.scatter(impact_point[0], impact_point[1], impact_point[2], \n                         c=colors['impact_point'], s=200, marker='*', \n                         edgecolors='black', linewidth=2, \n                         label='Impact')\n    \n    def _render_penetration_channel(self, channel_data: Dict[str, np.ndarray]):\n        \"\"\"Render the penetration channel geometry.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        if 'entry_vertices' in channel_data:\n            entry_verts = channel_data['entry_vertices']\n            \n            # Entry hole\n            if len(entry_verts) > 2:\n                entry_collection = Poly3DCollection([entry_verts], alpha=0.8,\n                                                  facecolors=colors['penetration'],\n                                                  edgecolors='darkred', linewidths=2)\n                self.ax_3d.add_collection3d(entry_collection)\n        \n        if 'exit_vertices' in channel_data:\n            exit_verts = channel_data['exit_vertices']\n            \n            # Exit hole (if exists)\n            if len(exit_verts) > 2:\n                exit_collection = Poly3DCollection([exit_verts], alpha=0.6,\n                                                 facecolors=colors['penetration'],\n                                                 edgecolors='darkred', linewidths=2)\n                self.ax_3d.add_collection3d(exit_collection)\n                \n                # Connect entry and exit with channel walls\n                if 'entry_vertices' in channel_data:\n                    self._create_penetration_channel_walls(\n                        channel_data['entry_vertices'], \n                        channel_data['exit_vertices']\n                    )\n        \n        # Render fragments if present\n        if 'penetrator_fragments' in channel_data:\n            for fragment in channel_data['penetrator_fragments']:\n                self.ax_3d.scatter(fragment[0], fragment[1], fragment[2], \n                                 c='red', s=20, alpha=0.8, marker='s')\n    \n    def _create_penetration_channel_walls(self, entry_verts: np.ndarray, exit_verts: np.ndarray):\n        \"\"\"Create walls connecting entry and exit holes.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Create wall segments\n        wall_faces = []\n        n_verts = min(len(entry_verts), len(exit_verts))\n        \n        for i in range(n_verts):\n            next_i = (i + 1) % n_verts\n            \n            # Create quad face for wall segment\n            wall_face = [\n                entry_verts[i],\n                entry_verts[next_i], \n                exit_verts[next_i],\n                exit_verts[i]\n            ]\n            wall_faces.append(wall_face)\n        \n        if wall_faces:\n            wall_collection = Poly3DCollection(wall_faces, alpha=0.4,\n                                             facecolors=colors['penetration'],\n                                             edgecolors='darkred', linewidths=1)\n            self.ax_3d.add_collection3d(wall_collection)\n    \n    def _render_armor_response(self, armor_response: Dict[str, Any]):\n        \"\"\"Render armor deformation and response visualization.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Render deformation zone\n        if 'deformation_zone' in armor_response:\n            deformation = armor_response['deformation_zone']\n            center = deformation['center']\n            radius = deformation['radius']\n            \n            # Create deformation sphere\n            u = np.linspace(0, 2 * np.pi, 10)\n            v = np.linspace(0, np.pi, 10)\n            \n            x_sphere = center[0] + radius * np.outer(np.cos(u), np.sin(v))\n            y_sphere = center[1] + radius * np.outer(np.sin(u), np.sin(v))\n            z_sphere = center[2] + radius * np.outer(np.ones(np.size(u)), np.cos(v))\n            \n            self.ax_3d.plot_surface(x_sphere, y_sphere, z_sphere, alpha=0.3, \n                                  color='orange', linewidth=0)\n        \n        # Render crack patterns\n        if 'crack_patterns' in armor_response:\n            for crack in armor_response['crack_patterns']:\n                if len(crack) == 2:  # Start and end points\n                    self.ax_3d.plot([crack[0][0], crack[1][0]], \n                                   [crack[0][1], crack[1][1]], \n                                   [crack[0][2], crack[1][2]], \n                                   color='red', linewidth=2, alpha=0.8)\n    \n    def _render_behind_armor_effects(self, behind_armor_effects: Dict[str, Any]):\n        \"\"\"Render behind-armor effects visualization.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Render spall cone\n        if 'spall_cone' in behind_armor_effects:\n            spall_data = behind_armor_effects['spall_cone']\n            apex = spall_data['apex']\n            base_verts = spall_data['base_vertices']\n            \n            # Create spall cone surfaces\n            spall_faces = []\n            n_base = len(base_verts)\n            \n            # Side faces of cone\n            for i in range(n_base):\n                next_i = (i + 1) % n_base\n                face = [apex, base_verts[i], base_verts[next_i]]\n                spall_faces.append(face)\n            \n            # Base face\n            if n_base > 2:\n                spall_faces.append(base_verts)\n            \n            if spall_faces:\n                spall_collection = Poly3DCollection(spall_faces, alpha=0.5,\n                                                  facecolors=colors['spall'],\n                                                  edgecolors='darkorange', linewidths=1)\n                self.ax_3d.add_collection3d(spall_collection)\n        \n        # Render fragments\n        if 'fragments' in behind_armor_effects:\n            for fragment_pos in behind_armor_effects['fragments']:\n                self.ax_3d.scatter(fragment_pos[0], fragment_pos[1], fragment_pos[2], \n                                 c=colors['spall'], s=15, alpha=0.7, marker='o')\n        \n        # Render molten spray (for HEAT)\n        if 'molten_spray' in behind_armor_effects:\n            for spray_point in behind_armor_effects['molten_spray']:\n                self.ax_3d.scatter(spray_point[0], spray_point[1], spray_point[2], \n                                 c='yellow', s=8, alpha=0.6, marker='.')\n    \n    def _render_environmental_effects(self, environmental_conditions: Dict[str, float]):\n        \"\"\"Render environmental effects visualization.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Create wind field visualization\n        wind_data = self.environmental_effects.create_wind_visualization(\n            environmental_conditions.get('wind_speed', 0),\n            environmental_conditions.get('wind_direction', 0)\n        )\n        \n        # Render wind vectors (subset for clarity)\n        wind_vectors = wind_data['vectors'][::4]  # Every 4th vector\n        \n        for vector_data in wind_vectors:\n            pos = vector_data['position']\n            vec = vector_data['vector']\n            \n            # Scale vector for visibility\n            scale = 0.5\n            end_pos = [pos[0] + vec[0] * scale, \n                      pos[1] + vec[1] * scale, \n                      pos[2] + vec[2] * scale]\n            \n            # Draw wind vector arrow\n            self.ax_3d.quiver(pos[0], pos[1], pos[2], \n                            vec[0], vec[1], vec[2], \n                            length=scale, alpha=0.4, \n                            color=colors['environment'], \n                            arrow_length_ratio=0.3)\n        \n        # Create temperature gradient visualization\n        temp_data = self.environmental_effects.create_temperature_gradient(\n            environmental_conditions.get('temperature', 15),\n            environmental_conditions.get('temperature', 15) - 6.5  # Standard lapse rate\n        )\n        \n        # Render temperature layers (simplified)\n        for layer in temp_data['temperature_layers'][::2]:  # Every other layer\n            altitude = layer['altitude']\n            temp = layer['temperature']\n            \n            # Color based on temperature (blue=cold, red=hot)\n            temp_normalized = (temp + 20) / 60  # Normalize to 0-1 range\n            temp_color = plt.cm.coolwarm(temp_normalized)\n            \n            # Create thin horizontal planes for temperature layers\n            x_temp = [-2, 22]\n            y_temp = [-6, 6]\n            xx, yy = np.meshgrid(x_temp, y_temp)\n            zz = np.ones_like(xx) * altitude\n            \n            self.ax_3d.plot_surface(xx, yy, zz, alpha=0.1, \n                                  color=temp_color, linewidth=0)\n    \n    def _setup_interactive_controls(self, ammunition, armor, environmental_conditions):\n        \"\"\"Set up interactive control widgets.\"\"\"\n        \n        # Adjust the main 3D axis to make room for controls\n        self.ax_3d.set_position([0.1, 0.15, 0.8, 0.8])  # [left, bottom, width, height]\n        \n        # Create control area at the bottom\n        control_height = 0.12\n        \n        # View angle controls\n        ax_elevation = self.fig.add_axes([0.1, 0.05, 0.35, 0.03])\n        ax_azimuth = self.fig.add_axes([0.1, 0.01, 0.35, 0.03])\n        \n        self.sliders['elevation'] = Slider(ax_elevation, 'Elevation', -90, 90, \n                                          valinit=self.current_view_angle[0], \n                                          valfmt='%1.0f°')\n        self.sliders['azimuth'] = Slider(ax_azimuth, 'Azimuth', -180, 180, \n                                       valinit=self.current_view_angle[1], \n                                       valfmt='%1.0f°')\n        \n        # Environmental parameter controls\n        ax_wind_speed = self.fig.add_axes([0.55, 0.05, 0.35, 0.03])\n        ax_wind_dir = self.fig.add_axes([0.55, 0.01, 0.35, 0.03])\n        \n        self.sliders['wind_speed'] = Slider(ax_wind_speed, 'Wind Speed', 0, 20, \n                                          valinit=environmental_conditions.get('wind_speed', 5), \n                                          valfmt='%1.1f m/s')\n        self.sliders['wind_dir'] = Slider(ax_wind_dir, 'Wind Direction', 0, 360, \n                                        valinit=environmental_conditions.get('wind_direction', 45), \n                                        valfmt='%1.0f°')\n        \n        # Toggle buttons\n        ax_toggles = self.fig.add_axes([0.05, 0.85, 0.15, 0.12])\n        toggle_labels = ['Armor Zones', 'Trajectory', 'Environment']\n        toggle_states = [self.show_armor_zones, self.show_trajectory, self.show_environmental_effects]\n        \n        self.checkboxes['toggles'] = CheckButtons(ax_toggles, toggle_labels, toggle_states)\n        \n        # Connect callbacks\n        self._connect_control_callbacks(ammunition, armor)\n    \n    def _connect_control_callbacks(self, ammunition, armor):\n        \"\"\"Connect interactive control callbacks.\"\"\"\n        \n        def update_view(val):\n            \"\"\"Update 3D view angles.\"\"\"\n            elev = self.sliders['elevation'].val\n            azim = self.sliders['azimuth'].val\n            self.ax_3d.view_init(elev=elev, azim=azim)\n            self.fig.canvas.draw()\n        \n        def update_environmental(val):\n            \"\"\"Update environmental effects.\"\"\"\n            # This would require re-rendering - simplified for now\n            pass\n        \n        def toggle_elements(label):\n            \"\"\"Toggle visibility of different elements.\"\"\"\n            if label == 'Armor Zones':\n                self.show_armor_zones = not self.show_armor_zones\n            elif label == 'Trajectory':\n                self.show_trajectory = not self.show_trajectory\n            elif label == 'Environment':\n                self.show_environmental_effects = not self.show_environmental_effects\n            \n            # Would need re-rendering for full effect - simplified for now\n            pass\n        \n        # Connect callbacks\n        self.sliders['elevation'].on_changed(update_view)\n        self.sliders['azimuth'].on_changed(update_view)\n        self.sliders['wind_speed'].on_changed(update_environmental)\n        self.sliders['wind_dir'].on_changed(update_environmental)\n        self.checkboxes['toggles'].on_clicked(toggle_elements)\n    \n    def _apply_visual_styling(self):\n        \"\"\"Apply professional visual styling to the plot.\"\"\"\n        \n        colors = self.color_schemes[self.style]\n        \n        # Set title\n        self.fig.suptitle('Interactive 3D Tank Armor Penetration Analysis', \n                         fontsize=16, fontweight='bold', y=0.95)\n        \n        # Customize axis appearance\n        self.ax_3d.tick_params(axis='both', labelsize=8)\n        \n        # Add legend\n        self.ax_3d.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0), fontsize=9)\n        \n        # Set equal aspect ratio\n        self._set_equal_aspect_3d()\n        \n        # Tight layout\n        plt.tight_layout()\n    \n    def _set_equal_aspect_3d(self):\n        \"\"\"Set equal aspect ratio for 3D plot.\"\"\"\n        \n        # Get current axis limits\n        x_limits = self.ax_3d.get_xlim3d()\n        y_limits = self.ax_3d.get_ylim3d()\n        z_limits = self.ax_3d.get_zlim3d()\n        \n        # Calculate ranges\n        x_range = x_limits[1] - x_limits[0]\n        y_range = y_limits[1] - y_limits[0]\n        z_range = z_limits[1] - z_limits[0]\n        \n        # Use the maximum range for all axes\n        max_range = max(x_range, y_range, z_range)\n        \n        # Calculate centers\n        x_center = (x_limits[1] + x_limits[0]) / 2\n        y_center = (y_limits[1] + y_limits[0]) / 2\n        z_center = (z_limits[1] + z_limits[0]) / 2\n        \n        # Set equal limits\n        self.ax_3d.set_xlim3d([x_center - max_range/2, x_center + max_range/2])\n        self.ax_3d.set_ylim3d([y_center - max_range/2, y_center + max_range/2])\n        self.ax_3d.set_zlim3d([z_center - max_range/2, z_center + max_range/2])\n    \n    def save_visualization(self, filename: str, dpi: int = 300):\n        \"\"\"Save the current 3D visualization to file.\"\"\"\n        \n        if self.fig:\n            self.fig.savefig(filename, dpi=dpi, bbox_inches='tight', \n                           facecolor=self.fig.get_facecolor(), \n                           edgecolor='none')\n            print(f\"3D visualization saved to: {filename}\")\n        else:\n            print(\"No visualization to save. Create visualization first.\")\n    \n    def show_visualization(self):\n        \"\"\"Display the interactive 3D visualization.\"\"\"\n        \n        if self.fig:\n            plt.show()\n        else:\n            print(\"No visualization to show. Create visualization first.\")\n\n\nclass Animated3DRenderer(Interactive3DRenderer):\n    \"\"\"Extended renderer with animation capabilities.\"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.animation = None\n        self.animation_frames = []\n    \n    def create_animated_penetration_sequence(self, ammunition, armor, \n                                           impact_point: List[float],\n                                           impact_angle: float,\n                                           duration: float = 5.0) -> animation.FuncAnimation:\n        \"\"\"Create an animated sequence showing penetration process.\"\"\"\n        \n        # Set up figure similar to static version\n        self.fig = plt.figure(figsize=self.figsize)\n        self.ax_3d = self.fig.add_subplot(111, projection='3d')\n        self._setup_3d_environment()\n        \n        # Create tank model (static)\n        tank_model = self.visualizer.create_3d_tank_model('modern_mbt')\n        self._render_tank_model(tank_model)\n        \n        # Set up animation frames\n        fps = 30\n        total_frames = int(duration * fps)\n        \n        # Animation phases:\n        # 1. Projectile approach (40% of time)\n        # 2. Impact and penetration (30% of time) \n        # 3. Behind-armor effects (30% of time)\n        \n        approach_frames = int(total_frames * 0.4)\n        penetration_frames = int(total_frames * 0.3)\n        effects_frames = total_frames - approach_frames - penetration_frames\n        \n        def animate_frame(frame_num):\n            \"\"\"Animation function for each frame.\"\"\"\n            \n            self.ax_3d.clear()\n            self._setup_3d_environment()\n            self._render_tank_model(tank_model)\n            \n            if frame_num < approach_frames:\n                # Approach phase - show projectile moving toward target\n                progress = frame_num / approach_frames\n                projectile_pos = [\n                    impact_point[0] - (1 - progress) * 10,  # Start 10m back\n                    impact_point[1],\n                    impact_point[2] + (1 - progress) * 2   # Start 2m higher\n                ]\n                \n                self.ax_3d.scatter(projectile_pos[0], projectile_pos[1], projectile_pos[2],\n                                 c='red', s=50, marker='o')\n                \n            elif frame_num < approach_frames + penetration_frames:\n                # Penetration phase - show impact and channel formation\n                progress = (frame_num - approach_frames) / penetration_frames\n                \n                # Show impact effects growing\n                impact_radius = progress * 0.1\n                self._render_impact_blast(impact_point, impact_radius)\n                \n                # Show penetration channel forming\n                if progress > 0.5:\n                    channel_depth = (progress - 0.5) * 2 * 300  # Up to 300mm\n                    self._render_partial_penetration(impact_point, impact_angle, channel_depth)\n                \n            else:\n                # Behind-armor effects phase\n                progress = (frame_num - approach_frames - penetration_frames) / effects_frames\n                \n                # Show full penetration\n                self._render_partial_penetration(impact_point, impact_angle, 300)\n                \n                # Show behind-armor effects developing\n                spall_size = progress * 0.5\n                self._render_developing_spall_cone(impact_point, spall_size)\n                \n                # Show fragments spreading\n                fragment_spread = progress * 0.3\n                self._render_spreading_fragments(impact_point, fragment_spread)\n            \n            self.ax_3d.view_init(elev=30, azim=45 + frame_num * 0.5)  # Slow rotation\n            return []\n        \n        # Create animation\n        self.animation = animation.FuncAnimation(self.fig, animate_frame, \n                                               frames=total_frames, \n                                               interval=1000/fps, \n                                               blit=False, repeat=True)\n        \n        return self.animation\n    \n    def _render_impact_blast(self, impact_point: List[float], radius: float):\n        \"\"\"Render expanding impact blast effect.\"\"\"\n        \n        if radius <= 0:\n            return\n            \n        # Create expanding sphere for blast\n        u = np.linspace(0, 2 * np.pi, 10)\n        v = np.linspace(0, np.pi, 10)\n        \n        x_blast = impact_point[0] + radius * np.outer(np.cos(u), np.sin(v))\n        y_blast = impact_point[1] + radius * np.outer(np.sin(u), np.sin(v))\n        z_blast = impact_point[2] + radius * np.outer(np.ones(np.size(u)), np.cos(v))\n        \n        self.ax_3d.plot_surface(x_blast, y_blast, z_blast, alpha=0.6, \n                              color='orange', linewidth=0)\n    \n    def _render_partial_penetration(self, impact_point: List[float], \n                                  impact_angle: float, depth: float):\n        \"\"\"Render partial penetration channel.\"\"\"\n        \n        channel_length = depth / 1000  # Convert mm to meters\n        penetrator_diameter = 0.022\n        \n        # Create entry hole\n        angles = np.linspace(0, 2*np.pi, 8)\n        entry_verts = []\n        \n        for angle in angles:\n            x_offset = penetrator_diameter/2 * np.cos(angle)\n            y_offset = penetrator_diameter/2 * np.sin(angle)\n            entry_verts.append([\n                impact_point[0] + x_offset,\n                impact_point[1] + y_offset,\n                impact_point[2]\n            ])\n        \n        # Create partial channel\n        penetration_vector = [\n            -channel_length * np.cos(np.radians(impact_angle)),\n            0,\n            -channel_length * np.sin(np.radians(impact_angle))\n        ]\n        \n        channel_end = [\n            impact_point[0] + penetration_vector[0],\n            impact_point[1] + penetration_vector[1],\n            impact_point[2] + penetration_vector[2]\n        ]\n        \n        # Draw penetration line\n        self.ax_3d.plot([impact_point[0], channel_end[0]], \n                       [impact_point[1], channel_end[1]], \n                       [impact_point[2], channel_end[2]], \n                       color='red', linewidth=5, alpha=0.8)\n    \n    def _render_developing_spall_cone(self, impact_point: List[float], size: float):\n        \"\"\"Render developing spall cone behind armor.\"\"\"\n        \n        if size <= 0:\n            return\n            \n        cone_angle = 30\n        cone_length = size\n        \n        # Create cone\n        angles = np.linspace(0, 2*np.pi, 12)\n        cone_radius = cone_length * np.tan(np.radians(cone_angle))\n        \n        apex = [impact_point[0], impact_point[1], impact_point[2] - 0.3]  # Behind armor\n        \n        base_verts = []\n        for angle in angles:\n            x_offset = cone_radius * np.cos(angle)\n            y_offset = cone_radius * np.sin(angle)\n            base_verts.append([\n                apex[0] + x_offset,\n                apex[1] + y_offset,\n                apex[2] - cone_length\n            ])\n        \n        # Render spall cone\n        spall_faces = []\n        for i in range(len(base_verts)):\n            next_i = (i + 1) % len(base_verts)\n            face = [apex, base_verts[i], base_verts[next_i]]\n            spall_faces.append(face)\n        \n        if spall_faces:\n            spall_collection = Poly3DCollection(spall_faces, alpha=0.5,\n                                              facecolors='orange',\n                                              edgecolors='darkorange')\n            self.ax_3d.add_collection3d(spall_collection)\n    \n    def _render_spreading_fragments(self, impact_point: List[float], spread: float):\n        \"\"\"Render fragments spreading from impact point.\"\"\"\n        \n        if spread <= 0:\n            return\n            \n        # Create random fragment positions\n        np.random.seed(42)  # Consistent animation\n        n_fragments = 15\n        \n        for i in range(n_fragments):\n            # Random direction\n            theta = np.random.uniform(0, 2 * np.pi)\n            phi = np.random.uniform(0, np.pi)\n            \n            # Fragment position\n            fragment_pos = [\n                impact_point[0] + spread * np.sin(phi) * np.cos(theta),\n                impact_point[1] + spread * np.sin(phi) * np.sin(theta),\n                impact_point[2] - spread * np.cos(phi)\n            ]\n            \n            self.ax_3d.scatter(fragment_pos[0], fragment_pos[1], fragment_pos[2],\n                             c='red', s=10, alpha=0.7, marker='o')\n    \n    def save_animation(self, filename: str, fps: int = 30):\n        \"\"\"Save animation to file.\"\"\"\n        \n        if self.animation:\n            writer = animation.PillowWriter(fps=fps)\n            self.animation.save(filename, writer=writer)\n            print(f\"Animation saved to: {filename}\")\n        else:\n            print(\"No animation to save. Create animation first.\")\n\n\n# Export classes\n__all__ = ['Interactive3DRenderer', 'Animated3DRenderer']
